Past Paper 2018
===============

Question 1
----------

### a. b.

See RoomCode.java

### c.

#### i.

- Attributes are externally available by other classes.
- There are 4 attributes available via the following accessors
    - getCode
    - getBuilding
    - getFloor
    - getRoom
- There is only one instance variable
    - code

#### ii.

- There is only 1 instance variable of type String, code.
- code is a reference type variable as it is an object of type String.

#### iii.

- 'none'
- no methods are overloaded.
- The isEqualCode method shares the *functionality* of the Object.equals method, but the method name is not the same, so
  it is not an overload.

#### iv.

- toString is an override of the Object.toString() method.

#### v.

- encapsulation is the means by which access to information held by a class is achieved only by publically accessible
  methods.
- This prevents direct access to the data structures within the class.
- This is the case in the RoomCode class, where access is granted by accessor methods, and a setter method first
  verifies a code before updating the class instance variable.

### d.

#### i.

- RoomFinder depends on RoomCode
- RoomCode has no concept of a RoomFinder
- RoomCode is a dependancy of RoomFinder.

#### ii.

rooms is a reference variable, it references an Array object.

#STTfFSR### iii.

the method will provide a reference to the underlying rooms array, which will enable direct access to the array without
the encapsulation provided by the RoomFinder class.
This will allow the data to be changed outside of the control of the class, this could result in an array size larger
than the MAX_ROOMS constant for example.

Question 2
----------

### a.

See Feedable.java

### b, c.

See HungryFrog.java

### d.

- we could increment a static class variable, within the public constructor of the
  class.
    - `private static int instanceCount = 0;`
- This would be stored globally within the class and incremented every time the constructor was called.
    - `instanceCount++;`
- a public getter can tell us how many have been created.

```
public static int getInstanceCount()
{
	return instanceCount;
}
```

### e.

- Using an interface type allows method polymorphism, where the concrete class implementing the interface to be swapped
  easily for another class that also implements the interface.

### f.

#### i.

- hf is of type HungryFrog, which implements Feedable interface, and is therefore also of type Feedable.
- s is of type Snake, which also implements Feedable interface, and is therefore also of type Feedable.

#### ii.

- Method(s) within ZooKeeper will call further methods on the provided Feedable object.
- The ZooKeeper class does not need to know anything about the passed classes except that they implement the feed()
  method.
- The ZooKeeper class may call the feed method, and only requires a boolean response to acknowledge the feeding is
  complete.
- This could call Snake.feed(), HungryFrog.feed(), AngryChild.feed() the actual method called depends on the class
  passed as an argument.
- This is known as method polymorphism.

### g.

- Interfaces cannot hold instance variables, Abstract classes can.
- Classes can extend only one abstract class, but can implement multiple interfaces.
- Interface methods have the public modifier, Abstract Class methods may be default, protected, public.

Question 3
----------

### a.

See Walk.java

### b.

See WalkDiary.java

#### iii.

- Sets cannot guarantee the order of the items within, and would not allow for duplication of places within the list.
- Lists retain their order and so are a good choice.