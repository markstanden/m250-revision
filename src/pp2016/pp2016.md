# Past Paper 2016

## Question 1

### a.

See Document.java

### b.

#### i.

`public String text`
> where text is the reference variable

#### ii.

`public boolean equals(Document d)`
> where d is the formal argument

#### iii.

`text = aText;`
> where = is the assignment operator

#### iv.

`public class Document`
> where class is the keyword

### c.

#### i.

- toString is inherited from the Object Class.

#### ii.

- the output is the hex representation of the Object.hashCode() method.
- It is used mainly to identify reference objects whilst debugging.

### d.

#### i.

- 3

#### ii.

- doc1, doc4 -> Then Daniel
- doc2 -> Daniel
- doc3 -> smiled.

#### iii.

- doc3 and doc1 have different content in their text field, and so are not equal.
- doc1 and doc4 reference the same object and so they are referencially equal.
- because the reference the same object, they will both contain the same text, and thus they are also structurally
  equal.

## Question 2.

### a.

See Dream.java

### b.

See SleepyFrog.java

### c.

- DozyFrog, as a subclass of SleepyFrog will have access to all of SleepyFrog's public and protected methods.
- SleepyFrog implements the Dream interface, therefore must have implemented the public methods to do so.
- DozyFrog will have access to these methods by inhertance.
- DozyFrog can implement the interface, making use of the inherited methods.

### d.

- Interfaces and Abstract Classes both promote polymorphism by providing a list of methods for a class to work
  implement, and work to.
- Method polymorphism allows different implementations of the interface or subclasses of the abstract class to be
  replaced with each other.

- Both interfaces and Abstract classes can now provide method bodies. Although the intended use for this within
  interfaces was for legacy code.

- Only one Abstract class can be extended by a subclass. Multiple interfaces can be implemented.
- Abstract classes can declare instance variables, interfaces can declare only final static constants.